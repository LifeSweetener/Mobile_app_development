![#c5f015](https://via.placeholder.com/15/6ffda7/000000?text=+) <b>`ЧЕТВЁРТАЯ ПРАКТИКА`</b>  
![#f03c15](https://via.placeholder.com/15/f03c15/000000?text="+") `Прикреплённые изображения в директориях — это скриншоты с моего телефона с ОС Android 5.1.1 (Lollipop)`
# Mobile_app_development
The repository inculdes results of university mobile apps works

## ОПИСАНИЕ
<p>В каталоге лежит проект <b>"practice4"</b>, в котором содержится пять модулей, плюс, в этом каталоге находится отдельный проект с выполненным завершающим эту практику контрольным заданием (шестым по счёту).</p>
  <h3>Список модулей</h3>
  <p><ol>
  <li><p><b>app</b> — это модуль, где решено самое первое задание практики — <b>"Thread"</b>.</p></li>
  <li><p><b>data_thread</b> — второе задание четвёртой практики, в котором нас знакомят с тремя Android-методами, позволяющими главному потоку приложения спокойно перерисовать UI-объект View без плохих последствий: <i>runOnUiThread()</i>, <i>post()</i> и <i>postDelayed()</i>. С их помощью дополнительные потоки, которые мы сами создаём, могут передать сообщение главному потоку, чтобы тот выполнил какую-нибудь задачу, часто связанную с визуальным изменением GUI.</p>
    <p>В программе сначала запустится метод <i>runn1()</i>, потом <i>runn2()</i>, а последним выполнится - <i>runn3()</i>, которые перерисуют текстовую метку интерфейса.</p>
    <p>Используя один главный поток приложения "UI thread", мы не сможем одновременно вычислить что-то, а потом как результат вычислений перерисовать элемент View, потому что у этого главного потока слишком мало времени на это - ему нужно делать ещё кучу задач. У UI-потока просто кончится время на перерисовку элемента пользовательского интерфейса. <p>Поэтому были придуманы методы <b>runOnUiThread()</b>, <b>post()</b> и <b>postDelayed()</b>, чтобы <b>разделить вычисления и перерисовку View</b>. Вычисления производит второстепенный поток, который мы создаём, а перерисовку - главный поток, чем он и должен заниматься. А это означает, что времени на перерисовку элемента у главного UI-потока будет предостаточно, и не произойдёт никакой ошибки в приложении.</p>
    <p>Метод runOnUiThread() полезен при перерисовке какого-то одного View: мы создаём свой второстепенный поток, в нём делаем вычислительные операции и в нём же вызываем этот метод, чтобы передать операцию перерисовки конкретного View главному потоку.
<p>Методы post() и postDelayed() полезны, когда у нас имеется множество разных View, и нам нужно все их перерисовать одновременно. Главный поток по очереди, друг за другом перерисовывает их, пока выполняются вычисления в нашем дополнительном потоке.</p>
    <p>Таким образом, наши дополнительные потоки передают сообщения главному UI-потоку, чтобы он выполнил визуальное редактирование элементов View, то есть так потоки могут <b>общаться между собой</b>.</p>
  </li>
  <li><p><b>loadermanager</b> — в этом задании мы работаем с загрузчиком, который является вспомогательным компонентом нашего Android-приложения, с помощью которого наше приложение способно подгружать данные из сторонних хранилищ: баз данных, сетевых ресурсов, локальных файлов и т.п.</p>
    <p>К этому модулю прикреплены в этом каталоге три скриншота с моего телефона (смотри в папке <b>"screenshots"</b>).</p>
    <p>Для управления загрузчиками нашего приложения существует LoaderManager, который может запускать конкретный загрузчик для загрузки данных в приложение — <i>loaderManager.initLoader(LoaderID, bundle, this);</i> — и удалять его — <i>loaderManager.destroyLoader(LoaderID);</i>.</p>
    <p>У нас в программе по нажатии кнопки пользовательского интерфейса (см. прикреплённые скриншоты) мы запускаем загрузчик, передаём ему данные (строку, которую ввёл пользователь в элемент EditText), он их у себя модифицирует (переставляет буквы строки местами) и возвращает нам. А мы в методе <i>onLoadFinished()</i>, который запускается после завершения загрузки данных загрузчиком, берём эту строку и вставляем в UI-элемент TextView.</p>
  </li>
  <li><p>Модуль <b>looper</b> — четвёртый модуль с очередным выполненным заданием практики, где нужно создать отдельный специальный поток <b>"Looper"</b>, который принимает сообщения с данными и обрабатывает их (одновременно с работой главного потока).</p></li>
  <li><p><b>workmanager</b> — модуль с пятым заданием, где используется компонент <b>"WorkManager"</b>, который управляет службами приложения, приостанавливая их при определённых условиях (отсутствии подключения к Интернету, процессе зарядки устройства), либо завершая, либо автоматически возобновляя их работу.</p>
    <p>Главный код (класса MainActivity) выглядит так:<br>
      <b>package ru.mirea.shayko.workmanager;<br><br>

import androidx.appcompat.app.AppCompatActivity;<br>
import androidx.work.Constraints;<br>
import androidx.work.NetworkType;<br>
import androidx.work.OneTimeWorkRequest;<br>
import androidx.work.WorkManager;<br>
import androidx.work.WorkRequest;<br><br>

import android.os.Bundle;<br><br>

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Constraints constraints = new Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build();

        WorkRequest uploadWorkRequest = new OneTimeWorkRequest.Builder(MyWorker.class).setConstraints(constraints).build();
        WorkManager.getInstance(this)
                     .enqueue(uploadWorkRequest);
    }
}
        </b></p>
        <p>В коде мы установили ограничение: если нет подключения к Интернету (посредством либо Wi-Fi, либо мобильной сети), то мы не запускаем метод <b>"doWork"</b> класса <b>"MyWorker"</b>. Если мы подключены к Интернету, то этот метод начинает выполняться.</p><p>Об этом можно судить, смотря на результат работы программы на скришотах (в папке <b>"screenshots"</b> этого каталога).</p></li>
  </ol></p>
